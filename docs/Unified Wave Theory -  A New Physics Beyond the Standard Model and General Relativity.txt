from pyscf import gto, scf, dft
import numpy as np

# Approximate C-S-H structure (symmetric initial setup)
atoms = [
    ['C', (0.0, 0.0, 0.0)],
    ['H', (0.63, 0.63, 0.63)],
    ['H', (0.63, -0.63, -0.63)],
    ['H', (-0.63, 0.63, -0.63)],
    ['H', (-0.63, -0.63, 0.63)],
    ['S', (1.5, 1.5, 1.5)]
]
mol = gto.M(
    atom=atoms,
    basis='cc-pvdz',
    symmetry=False,  # Disable symmetry to force breaking
    unit='Angstrom'
)

# UWT parameters
epsilon_cp = 2.58e-41
delta_eps_sc2 = 1.5e11  # J/m^3
phi1_phi2 = 1000  # GeV^2
me = 0.510998 / 27.2114  # Electron mass in a.u.

# Convert UWT units to atomic units
au_energy = 27.2114 * 1.602e-19  # Hartree to Joules
au_length = 5.29177e-11  # Bohr to meters
au_volume = au_length**3  # Bohr^3 to m^3
energy_density_au = delta_eps_sc2 / (au_energy / au_volume) * 1e-2

# Run DFT calculation (baseline)
mf = dft.RKS(mol)
mf.xc = 'pbe'
mf.max_cycle = 200
mf.diis = True
mf.level_shift = 2.0  # Increased for stability
energy_base = mf.kernel()
print(f"Baseline energy: {energy_base} Ha; Symmetry: {mol.groupname if mol.symmetry else 'Disabled'}")

# Iterative adjustment of UWT perturbation multiplier
target_shift = 0.01  # Target energy shift in Hartree
multiplier_low = 1.0
multiplier_high = 2.5
tolerance = 1e-8  # Tightened tolerance
max_iterations = 12
pert_scale = 0.01  # Increased from 1e-06

mf_base = mf.copy()  # Preserve baseline for MO comparison
mo_energy_base = mf.mo_energy
mo_coeff_base = mf.mo_coeff

for i in range(max_iterations):
    step = (multiplier_high - multiplier_low) / 2
    if i > 0:
        if abs(energy_shift) > 0.005:
            step /= 2  # Halve step if shift overshoots
        elif abs(energy_shift) < 0.001:
            step *= 2  # Double step if shift is small
    multiplier = multiplier_low + step
    uw_perturbation = np.zeros((mol.nao_nr(), mol.nao_nr()))
    for i in range(mol.nao_nr()):
        base_pert = (epsilon_cp * phi1_phi2 * multiplier * 1e2 * pert_scale) / (me**2)
        uw_perturbation[i, i] = base_pert
        if i % 2 == 0:
            uw_perturbation[i, i] += energy_density_au * multiplier * 1e-1 * pert_scale
        else:
            uw_perturbation[i, i] -= energy_density_au * multiplier * 1e-1 * pert_scale
    for i in range(mol.nao_nr()-1):
        if i % 2 == 0:
            uw_perturbation[i, i+1] = energy_density_au * multiplier * 1e-1 * 1000.0 * pert_scale
    hcore_with_uw = mf.get_hcore() + uw_perturbation  # Reverted to get_hcore with symmetry disabled
    mf.get_hcore = lambda *args: hcore_with_uw
    try:
        energy_with_uw = mf.kernel()
        prev_energy = getattr(mf, 'e_tot', energy_with_uw)
        if abs(energy_with_uw - prev_energy) > 1e-8:
            raise Exception("SCF not converged sufficiently")
    except Exception as e:
        print(f"SCF issue at multiplier {multiplier}: {e}, reducing by 0.05")
        multiplier -= 0.05
        uw_perturbation = np.zeros((mol.nao_nr(), mol.nao_nr()))
        for i in range(mol.nao_nr()):
            base_pert = (epsilon_cp * phi1_phi2 * multiplier * 1e2 * pert_scale) / (me**2)
            uw_perturbation[i, i] = base_pert
            if i % 2 == 0:
                uw_perturbation[i, i] += energy_density_au * multiplier * 1e-1 * pert_scale
            else:
                uw_perturbation[i, i] -= energy_density_au * multiplier * 1e-1 * pert_scale
        for i in range(mol.nao_nr()-1):
            if i % 2 == 0:
                uw_perturbation[i, i+1] = energy_density_au * multiplier * 1e-1 * 1000.0 * pert_scale
        hcore_with_uw = mf.get_hcore() + uw_perturbation
        mf.get_hcore = lambda *args: hcore_with_uw
        energy_with_uw = mf.kernel()
    energy_shift = energy_with_uw - energy_base
    mo_energy_pert = mf.mo_energy
    mo_coeff_pert = mf.mo_coeff
    mo_l2_diff = np.linalg.norm(mo_energy_pert - mo_energy_base)
    print(f"Iter {i}: mult={multiplier:.8f}, energy={energy_with_uw}, shift={energy_shift}, pert_scale={pert_scale}")
    print(f"  MO L2 diff: {mo_l2_diff:.3e}")
    if abs(energy_shift - target_shift) < tolerance:
        break
    elif energy_shift < target_shift:
        multiplier_low = multiplier
    else:
        multiplier_high = multiplier

print(f"Final result:")
print(f" multiplier={multiplier}, energy={energy_with_uw}, shift={energy_shift}")
print(f"Baseline MO energies: {mo_energy_base}")
print(f"Perturbed MO energies: {mo_energy_pert}")