from pyscf import gto, scf, dft
import numpy as np

# Approximate C-S-H structure (symmetric initial setup)
atoms = [
    ['C', (0.0, 0.0, 0.0)],
    ['H', (0.63, 0.63, 0.63)],
    ['H', (0.63, -0.63, -0.63)],
    ['H', (-0.63, 0.63, -0.63)],
    ['H', (-0.63, -0.63, 0.63)],
    ['S', (1.5, 1.5, 1.5)]
]
mol = gto.M(
    atom=atoms,
    basis='cc-pvdz',
    symmetry=True,  # Enable symmetry analysis
    unit='Angstrom'
)

# UWT parameters from addendum
epsilon_cp = 2.58e-41  # CP-violating phase control
delta_eps_sc2 = 1.5e11  # J/m^3 from addendum
phi1_phi2 = 1000  # |Φ_1 Φ_2| in GeV^2
me = 0.510998 / 27.2114  # Electron mass in a.u. from UWT

# Convert UWT units to atomic units
au_energy = 27.2114 * 1.602e-19  # Hartree to Joules
au_length = 5.29177e-11  # Bohr to meters
au_volume = au_length**3  # Bohr^3 to m^3
energy_density_au = delta_eps_sc2 / (au_energy / au_volume) * 1e-2

# Run DFT calculation (baseline)
mf = dft.RKS(mol)
mf.xc = 'pbe'
mf.max_cycle = 200  # Increase max cycles
mf.diis = True      # Enable DIIS
mf.level_shift = 0.9  # Increase level shift
energy_base = mf.kernel()
print(f"Baseline C-S-H DFT energy: {energy_base} Hartree")
print(f"Symmetry group (baseline): {mol.groupname}")

# Iterative adjustment of UWT perturbation multiplier with dynamic steps
target_shift = 0.01  # Target energy shift in Hartree (e.g., 272 meV)
multiplier_low = 1.0  # Lower bound
multiplier_high = 2.5  # Extended upper bound
tolerance = 1e-5  # Relaxed tolerance for speed
max_iterations = 12  # Increase iterations for precision
symmetric_perturbation = False  # Intentional symmetry breaking

for i in range(max_iterations):
    step = (multiplier_high - multiplier_low) / 2
    if i > 0:
        if abs(energy_shift) > 0.005:
            step /= 2  # Halve step if shift overshoots
        elif abs(energy_shift) < 0.001:
            step *= 2  # Double step if shift is small
    multiplier = multiplier_low + step
    uw_perturbation = np.zeros((mol.nao_nr(), mol.nao_nr()))
    for i in range(mol.nao_nr()):
        base_pert = (epsilon_cp * phi1_phi2 * multiplier * 1e2) / (me**2)  # Increased base scaling
        uw_perturbation[i, i] = base_pert
        if not symmetric_perturbation:  # Asymmetric perturbation
            if i % 2 == 0:
                uw_perturbation[i, i] += energy_density_au * multiplier * 1e0  # Increased scaling
            else:
                uw_perturbation[i, i] -= energy_density_au * multiplier * 1e0  # Increased scaling
    for i in range(mol.nao_nr()-1):
        if i % 2 == 0 and not symmetric_perturbation:
            uw_perturbation[i, i+1] = energy_density_au * multiplier * 1e-1 * 0.5  # Enhanced off-diagonal
    hcore_with_uw = mf.get_hcore() + uw_perturbation
    mf.get_hcore = lambda *args: hcore_with_uw
    try:
        energy_with_uw = mf.kernel()
    except Exception:
        print(f"SCF not converged at multiplier {multiplier}, reducing by 0.1")
        multiplier -= 0.1
        uw_perturbation = np.zeros((mol.nao_nr(), mol.nao_nr()))
        for i in range(mol.nao_nr()):
            base_pert = (epsilon_cp * phi1_phi2 * multiplier * 1e2) / (me**2)
            uw_perturbation[i, i] = base_pert
            if not symmetric_perturbation:
                if i % 2 == 0:
                    uw_perturbation[i, i] += energy_density_au * multiplier * 1e0
                else:
                    uw_perturbation[i, i] -= energy_density_au * multiplier * 1e0
        for i in range(mol.nao_nr()-1):
            if i % 2 == 0 and not symmetric_perturbation:
                uw_perturbation[i, i+1] = energy_density_au * multiplier * 1e-1 * 0.5
        hcore_with_uw = mf.get_hcore() + uw_perturbation
        mf.get_hcore = lambda *args: hcore_with_uw
        energy_with_uw = mf.kernel()
    energy_shift = energy_with_uw - energy_base
    print(f"Multiplier: {multiplier}, Energy with UWT: {energy_with_uw} Hartree, Shift: {energy_shift} Hartree")
    if abs(energy_shift - target_shift) < tolerance:
        break
    elif energy_shift < target_shift:
        multiplier_low = multiplier
    else:
        multiplier_high = multiplier

print(f"Final C-S-H DFT energy with UWT perturbation: {energy_with_uw} Hartree")
print(f"Final Predicted UWT energy shift: {energy_shift} Hartree with multiplier {multiplier}")
print(f"Symmetry group (with UWT): {mol.groupname if hasattr(mol, 'groupname') else 'Symmetry broken'}")

# Analyze orbital symmetry
mo_energy = mf.mo_energy
mo_coeff = mf.mo_coeff
print(f"MO energies (baseline): {mo_energy}")
print(f"MO energies (with UWT): {mf.mo_energy}")